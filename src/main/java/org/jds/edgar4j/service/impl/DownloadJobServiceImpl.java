package org.jds.edgar4j.service.impl;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.jds.edgar4j.dto.request.DownloadRequest;
import org.jds.edgar4j.dto.response.DownloadJobResponse;
import org.jds.edgar4j.model.DownloadJob;
import org.jds.edgar4j.model.DownloadJob.JobStatus;
import org.jds.edgar4j.model.DownloadJob.JobType;
import org.jds.edgar4j.repository.DownloadJobRepository;
import org.jds.edgar4j.service.DownloadJobService;
import org.jds.edgar4j.service.DownloadSubmissionsService;
import org.jds.edgar4j.service.DownloadTickersService;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class DownloadJobServiceImpl implements DownloadJobService {

    private final DownloadJobRepository downloadJobRepository;
    private final DownloadJobExecutor downloadJobExecutor;

    @Override
    public DownloadJobResponse startDownload(DownloadRequest request) {
        log.info("Starting download job: {}", request);

        JobType jobType = mapToJobType(request.getType());

        DownloadJob job = DownloadJob.builder()
                .type(jobType)
                .description(getJobDescription(jobType, request.getCik()))
                .status(JobStatus.PENDING)
                .progress(0)
                .startedAt(LocalDateTime.now())
                .cik(request.getCik())
                .userAgent(request.getUserAgent())
                .build();

        job = downloadJobRepository.save(job);

        downloadJobExecutor.executeDownloadAsync(job.getId(), request);

        return toDownloadJobResponse(job);
    }

    @Override
    public Optional<DownloadJobResponse> getJobById(String jobId) {
        return downloadJobRepository.findById(jobId).map(this::toDownloadJobResponse);
    }

    @Override
    public List<DownloadJobResponse> getRecentJobs(int limit) {
        return downloadJobRepository.findTop10ByOrderByStartedAtDesc().stream()
                .limit(limit)
                .map(this::toDownloadJobResponse)
                .collect(Collectors.toList());
    }

    @Override
    public List<DownloadJobResponse> getActiveJobs() {
        return downloadJobRepository.findByStatusIn(Arrays.asList(JobStatus.PENDING, JobStatus.IN_PROGRESS))
                .stream()
                .map(this::toDownloadJobResponse)
                .collect(Collectors.toList());
    }

    @Override
    public DownloadJob updateJobProgress(String jobId, int progress, long filesDownloaded) {
        DownloadJob job = downloadJobRepository.findById(jobId)
                .orElseThrow(() -> new RuntimeException("Job not found: " + jobId));

        job.setProgress(progress);
        job.setFilesDownloaded(filesDownloaded);
        return downloadJobRepository.save(job);
    }

    @Override
    public DownloadJob completeJob(String jobId) {
        DownloadJob job = downloadJobRepository.findById(jobId)
                .orElseThrow(() -> new RuntimeException("Job not found: " + jobId));

        job.setStatus(JobStatus.COMPLETED);
        job.setProgress(100);
        job.setCompletedAt(LocalDateTime.now());
        return downloadJobRepository.save(job);
    }

    @Override
    public DownloadJob failJob(String jobId, String error) {
        DownloadJob job = downloadJobRepository.findById(jobId)
                .orElseThrow(() -> new RuntimeException("Job not found: " + jobId));

        job.setStatus(JobStatus.FAILED);
        job.setError(error);
        job.setCompletedAt(LocalDateTime.now());
        return downloadJobRepository.save(job);
    }

    @Override
    public void cancelJob(String jobId) {
        DownloadJob job = downloadJobRepository.findById(jobId)
                .orElseThrow(() -> new RuntimeException("Job not found: " + jobId));

        job.setStatus(JobStatus.CANCELLED);
        job.setCompletedAt(LocalDateTime.now());
        downloadJobRepository.save(job);
    }

    private JobType mapToJobType(DownloadRequest.DownloadType type) {
        switch (type) {
            case TICKERS_ALL:
                return JobType.TICKERS_ALL;
            case TICKERS_NYSE:
                return JobType.TICKERS_NYSE;
            case TICKERS_NASDAQ:
                return JobType.TICKERS_NASDAQ;
            case TICKERS_MF:
                return JobType.TICKERS_MF;
            case SUBMISSIONS:
                return JobType.SUBMISSIONS;
            case BULK_SUBMISSIONS:
                return JobType.BULK_SUBMISSIONS;
            case BULK_COMPANY_FACTS:
                return JobType.BULK_COMPANY_FACTS;
            default:
                throw new IllegalArgumentException("Unknown type: " + type);
        }
    }

    private String getJobDescription(JobType type, String cik) {
        switch (type) {
            case TICKERS_ALL:
                return "Download All Company Tickers";
            case TICKERS_NYSE:
                return "Download NYSE Tickers";
            case TICKERS_NASDAQ:
                return "Download NASDAQ Tickers";
            case TICKERS_MF:
                return "Download Mutual Fund Tickers";
            case SUBMISSIONS:
                return "Download Submissions for CIK " + cik;
            case BULK_SUBMISSIONS:
                return "Download Bulk Submissions Archive";
            case BULK_COMPANY_FACTS:
                return "Download Company Facts XBRL Archive";
            default:
                return "Unknown Job Type";
        }
    }

    private DownloadJobResponse toDownloadJobResponse(DownloadJob job) {
        return DownloadJobResponse.builder()
                .id(job.getId())
                .type(job.getType().name())
                .description(job.getDescription())
                .status(DownloadJobResponse.JobStatus.valueOf(job.getStatus().name()))
                .progress(job.getProgress())
                .error(job.getError())
                .startedAt(job.getStartedAt())
                .completedAt(job.getCompletedAt())
                .filesDownloaded(job.getFilesDownloaded())
                .totalFiles(job.getTotalFiles())
                .build();
    }
}

